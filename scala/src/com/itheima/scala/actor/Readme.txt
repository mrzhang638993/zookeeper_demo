#  java 并发编程存在的问题：
1.在Java并发编程中，每个对象都有一个逻辑监视器（monitor），可以用来控制对象的多线程访问。
我们添加sychronized关键字来标记，需要进行同步加锁访问。
这样，通过加锁的机制来确保同一时间只有一个线程访问共享数据。
但这种方式存在资源争夺、以及死锁问题，程序越大问题越麻烦。
缺点：使用对象的monitor来实现并发编程下面的访问的。synchronized实现访问的机制是在对象上面加锁的。可以确保资源共享是没有任何的问题的
存在资源争夺和死锁的问题的。monitor位于java的对象中的。
2.java的并发编程是基于线程的并发编程模型，java的并发编程需要依赖于资源共享的,设计到资源的抢夺。常见的并发编程框架是jdk提供的execuator并发编程框架的
scala的并发编程模型是基于事件的并发编程框架的。基于消息来进行并发编程的，可以有效的避免资源争夺和死锁的问题的。
3.开发scala的并发编程主要使用了Akka的并发编程问题。actor程序每一个程序都是并发执行的，和java中的多线程程序是一样的。

scala发送消息
1.！异步发送消息，没有返回值。！代表的是方法的调用
2.!?同步发送消息，等待返回值
3.!!发送异步消息，返回值是Future[Any]


在actor中需要怎么样发送和接收消息？
actor底层是基于线程实现的，当receive没有数据的请求的时候，会出现卡顿的现象。解决问题的方法如下：
1.采用loop加上react来复用线程，相较于while加上receive更加的高效的
{}可是可以调用方法的。


下面演示的是发送同步消息和异步消息


